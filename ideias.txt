---Apontamentos Enunciado----
Zonas de atracagem:
    ZonaA: para navios de grande porte (porta-contentores, navios de cruzeiro, etc.).
    ZonaB: para navios de médio e pequeno porte (pesqueiros,cargueiros ligeiros, etc.).


Tipos de navios:
    Tipo1: navios versáteis, que podem atracar na Zona A ou na Zona B.
    Tipo2: navios restritos, que apenas podem atracar na Zona A devido ao seu tamanho e requisitos técnicos.

Objetivo do trabalho:
    -Determinar qual a melhor sequência de atracagem, minimizandoo tempo de espera total e evitando bloqueios.

    -Os bloqueios neste problema tratam-se de navios que não podemser atracados por falta de compatibilidade.

Requisitos e Considerações:
    Cada zona apenas pode receber um navio de cada vez
    A duração de atracagem é variável dependendo do tipo de navio
    O sistema deve considerar que:
        Se a Zona A estiver ocupada e um navio do Tipo 2 estiver na fila, o sistema deve decidir se atraca primeiro outro navio ou mantém a Zona B livre à espera do próximo navio possível.
        A ordem de chegada deve ser respeitada sempre que possível, mas o sistema pode reordenar para otimizar o fluxo global.

    O algoritmo deve encontrar uma sequência válida de atracagens que minimize:
        tempo total de espera dos navios,
        ou o tempo médio de utilização das zonas.

---pensamentos iniciais----
Estado n, vai conter diversas variáveis como:
    Disponibilidade da zona A; aqui também vai envolver o tempo mas é mais o de espera
    Disponibilidade da zona B; "
    Fila de espera: que engloba todos os navios por atracar 
                    estes têm variáveis associadas: ID_Navio, Tipo, Zona_Permitido, 
                                                    Porto_Origem, Tipo_carga, Hora_Chegada, 
                                                    Duracao_Atracagem, Prioridade

podemos considerar: Estado = ( ZonaA,ZonaB,Fila), o tempo talvez sai por causa do calculo do custo

Estado inicial:
        ZonaA : 0.0, disponível; estou a considerar como a marcação do tempo
        ZonaB : 0.0, disponível; "
        Fila: inicialmente vai ter todos os navios presentes no ficheiro
   ( o custo acumulado está a zero)

Estado Final:
    Considera-se no estado final, quando a fila de espera estiver vazia, ou seja quando todos os barcos já foram atracados

Operadores:
    Para cada navioX na fila de espera, o operador tenta a atracagem na zonaY.
    tipo1: pode atracar em A e barcos
    tipo2: apenas atraca em A 

Custos associados:
como o objetivo é minimizar o tempo total de espera dos navios, o custo do caminho é potencialmente a soma de todos os tempos de espera

custo(n->n') é o tempo em que o navio atracado teve de espera
    tempo de inicio de atracagem vai ser a junção do tempo desde a hora de chegada, até ao momento em que a zona ficou livre

    e o custo podemos representar como se fosse a diferença entre o  tempo de inicio de atracagem  calculado anteriormente e a hora a que o navio chegou.
    tempos de espera maiores, têm um custo maiores

o custo acumulado fica assim:

            g(n')= g(n) + o custo calculado anteriormente (podemos chamar de custo de espera ig?)

sendo g(n') o tempo total de espera dos navios todos que já foram atracados


-----Construção----
Criar a classe geral que neste caso vai ser a definição do estado
        idealização física do porto 
        algo fixo e definitivo
        basicamente a base do que é um estado neste trabalho


Criar uma classe para as regras para ficar mais organizado e fácil de correção em caso de erro
        definir como o sistema funciona
        como é que ele se desconstrói
        e o custo


Como precisamos de garantir otimização talvez seja uma boa opção a utilização da Busca de Custo Uniforme
    desta forma podemos assegurar o menor tempo de espera total
    os tempos de espera não podem ser negativos

        utilização do:
        Custo acumulado: já idealizado anteriormente
        Custo da ação: já idealizado anteriormente
    
    garante também que um navio só vai atracar se não existir outro caminho com menor tempo de espera total a ser explorado.(Prioridade)
        assim vamos resolvemos a questão das zonas e se temos de deixar a zona B livre à espera dos navios
        O foco é sempre o menos custo possivel.

Serie interessante comparar este modelo ao de Busca em Largura, uma vez que este ignora o custo e prioriza o caminho com o menor número de nós.
    Este algoritmo funciona com a estratégia de First In First Out (FIFO).
    Apenas minimiza o número de passos (o que é estranho pq todos os caminhos válidos terão o mesmo número de navios)


colocar os resultados num ficheiro





def custo_uniforme(regras):
    contador = itertools.count()  # Tie-breaker
    fila_prioritaria = []         # Heap: (custo, ordem, estado)
    melhor_custo = {}             # Guarda o menor custo encontrado para cada estado
    caminho = {}                  # Guarda o predecessor de cada estado

    estado_inicial = regras.estado_inicial
    heapq.heappush(fila_prioritaria, (0.0, next(contador), estado_inicial))

    melhor_custo[estado_inicial] = 0.0
    caminho[estado_inicial] = None

    estados_explorados = 0

    while fila_prioritaria:

        custo_atual, _, estado_atual = heapq.heappop(fila_prioritaria)

       
        if custo_atual > melhor_custo.get(estado_atual, float('inf')):
            continue

        estados_explorados += 1
        
        if regras.e_estado_final(estado_atual):
            print(f"Estados explorados: {estados_explorados}")
            return custo_atual, caminho, estados_explorados, estado_atual

      
        for estado_sucessor, custo_acao in regras.simular_sucessores(estado_atual):
            novo_custo = custo_atual + custo_acao
            if novo_custo < melhor_custo.get(estado_sucessor, float('inf')):
                melhor_custo[estado_sucessor] = novo_custo
                caminho[estado_sucessor] = (estado_atual, custo_acao)
                heapq.heappush(fila_prioritaria, (novo_custo, next(contador), estado_sucessor))

    # Se esgotou e não encontrou solução
    return None, None, estados_explorados, None